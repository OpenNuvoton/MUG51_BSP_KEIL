C51 COMPILER V9.52.0.0   IAP                                                               05/07/2021 15:15:29 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE IAP
OBJECT MODULE PLACED IN .\Output\IAP.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\..\..\Library\StdDriver\src\IAP.c LARGE OMF2 BROWSE INCDIR(..\..\Comm
                    -on;..\..\..\..\Library\Device\Include;..\..\..\..\Library\StdDriver\inc) DEBUG PRINT(.\List\IAP.lst) TABS(2) OBJECT(.\Ou
                    -tput\IAP.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2021 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          /*********************************************************************************************************
             -***
   8            Website: http://www.nuvoton.com
   9            E-Mail : MicroC-8bit@nuvoton.com
  10          **********************************************************************************************************
             -**/
  11          
  12          #include "MUG51.h"
  13          unsigned char xdata DIDBuffer[4];
  14          unsigned char xdata UIDBuffer[9];
  15          unsigned char xdata UCIDBuffer[12];
  16          unsigned char xdata IAPDataBuf[128];
  17          unsigned char xdata IAPCFBuf[5];
  18          
  19          
  20          /**
  21           * @brief       Erase LDROM  
  22           * @param       u16IAPStartAddress define LDROM area start address
  23           * @param       u16IAPDataSize define LDROM need be erase bytes size
  24           * @return      none
  25           * @details     Page erase LDROM area base on data start address 
  26           * @example      Erase_LDROM(0x0000,2048);
  27           */
  28          void LDROM_Erase(unsigned int u16IAPStartAddress,unsigned int u16IAPDataSize)
  29          {   
  30   1          unsigned int u16Count;
  31   1      
  32   1          set_CHPCON_IAPEN;                    // Enable IAP function
  33   1          set_IAPUEN_LDUEN;                    //  LDROM modify Enable
  34   1          IAPFD = 0xFF;                        // IMPORTANT !! To erase function must setting IAPFD = 0xFF 
  35   1          IAPCN = PAGE_ERASE_LDROM;
  36   1          for(u16Count=0x0000;u16Count<(u16IAPDataSize/PAGE_SIZE);u16Count++)            // Loop page erase LDRO
             -M special define address area.
  37   1          {        
  38   2              IAPAL = LOBYTE(u16Count*PAGE_SIZE + u16IAPStartAddress);
  39   2              IAPAH = HIBYTE(u16Count*PAGE_SIZE + u16IAPStartAddress);
  40   2              set_IAPTRG_IAPGO_WDCLR;
  41   2          } 
  42   1          clr_IAPUEN_LDUEN;                    // Disable LDROM modify 
  43   1          clr_CHPCON_IAPEN;                    // Disable IAP
  44   1      }
  45          
C51 COMPILER V9.52.0.0   IAP                                                               05/07/2021 15:15:29 PAGE 2   

  46          /**
  47           * @brief       LDROM blank check
  48           * @param       u16IAPStartAddress define LDROM area start address
  49           * @param       u16IAPDataSize define LDROM need be erase bytes size
  50           * @return      none
  51           * @details     Check each byte of LDROM is FFH or not.
  52           * @example      LDROM_BlanckCheck(0x0000,2048);
  53           */
  54          void LDROM_Blank_Check(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
  55          {   
  56   1          unsigned int u16Count;
  57   1          set_CHPCON_IAPEN;
  58   1          IAPAL = LOBYTE(u16IAPStartAddress);
  59   1          IAPAH = HIBYTE(u16IAPStartAddress);
  60   1          IAPCN = BYTE_READ_LDROM;
  61   1      
  62   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
  63   1          {   
  64   2              IAPFD = 0x00;    
  65   2              set_IAPTRG_IAPGO;
  66   2              if(IAPFD != 0xFF)
  67   2                while(1);
  68   2              IAPAL++;
  69   2              if(IAPAL == 0x00)
  70   2                IAPAH++;
  71   2          } 
  72   1          clr_CHPCON_IAPEN;
  73   1      }
  74          
  75          /**
  76           * @brief       LDROM program loop
  77           * @param       u16IAPStartAddress define LDROM area start address
  78           * @param       u16IAPDataSize define LDROM need be erase bytes size
  79           * @return      none
  80           * @details     Copy IAPDataBuf to LDROM
  81           * @example      LDROM_Program(0x0000,1024);
  82           */
  83          void LDROM_Program(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
  84          {   
  85   1          unsigned int u16Count;
  86   1      
  87   1          set_CHPCON_IAPEN;
  88   1          set_IAPUEN_LDUEN;
  89   1          IAPAL = LOBYTE(u16IAPStartAddress);
  90   1          IAPAH = HIBYTE(u16IAPStartAddress);
  91   1          IAPCN = BYTE_PROGRAM_LDROM;
  92   1          
  93   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
  94   1          {   
  95   2              IAPFD = IAPDataBuf[u16Count];
  96   2              set_IAPTRG_IAPGO_WDCLR;
  97   2              IAPAL++;
  98   2              if(IAPAL == 0)
  99   2              {
 100   3                  IAPAH++;
 101   3              }
 102   2          } 
 103   1          clr_IAPUEN_LDUEN;
 104   1          clr_CHPCON_IAPEN;
 105   1      }
 106          
 107          
C51 COMPILER V9.52.0.0   IAP                                                               05/07/2021 15:15:29 PAGE 3   

 108          /**
 109           * @brief       LDROM check loop
 110           * @param       u16IAPStartAddress define LDROM area start address
 111           * @param       u16IAPDataSize define LDROM need be erase bytes size
 112           * @return      none
 113           * @details     Check with XRAM IAPDataBuf with LDROM
 114           * @example     LDROM_Program_Verify(0x0000,1024);
 115           */
 116          void LDROM_Read_Verify(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
 117          {   
 118   1          unsigned int u16Count;
 119   1      
 120   1          set_CHPCON_IAPEN;
 121   1          IAPAL = LOBYTE(u16IAPStartAddress);
 122   1          IAPAH = HIBYTE(u16IAPStartAddress);
 123   1          IAPCN = BYTE_READ_LDROM;
 124   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
 125   1          {   
 126   2              IAPFD = 0x00;
 127   2              set_IAPTRG_IAPGO;
 128   2              if (IAPFD != IAPDataBuf[u16Count])    
 129   2                  while(1);
 130   2              IAPAL++;
 131   2              if(IAPAL == 0)
 132   2              {
 133   3                  IAPAH++;
 134   3              }
 135   2          } 
 136   1          clr_CHPCON_IAPEN;
 137   1      }
 138          
 139          /**
 140           * @brief       Erase APROM  
 141           * @param       u16IAPStartAddress define APROM area start address
 142           * @param       u16IAPDataSize define LDROM need be erase bytes size
 143           * @return      none
 144           * @details     Page erase APROM area base on data start address 
 145           * @example     Erase_APROM(0x0000,2048);
 146           */
 147          void APROM_Erase(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
 148          {   
 149   1          unsigned int u16Count;
 150   1      
 151   1          set_CHPCON_IAPEN;                    // Enable IAP function
 152   1          set_IAPUEN_APUEN;                    // APROM modify Enable
 153   1          IAPFD = 0xFF;                        // IMPORTANT !! To erase function must setting IAPFD = 0xFF 
 154   1          IAPCN = PAGE_ERASE_APROM;
 155   1          for(u16Count=0x0000;u16Count<u16IAPDataSize/PAGE_SIZE;u16Count++)            // Loop page erase APROM 
             -special define address area.
 156   1          {        
 157   2              IAPAL = LOBYTE(u16Count*PAGE_SIZE + u16IAPStartAddress);
 158   2              IAPAH = HIBYTE(u16Count*PAGE_SIZE + u16IAPStartAddress);
 159   2              set_IAPTRG_IAPGO_WDCLR; 
 160   2          } 
 161   1          clr_IAPUEN_APUEN;                    // Disable APROM modify 
 162   1          clr_CHPCON_IAPEN;                    // Disable IAP
 163   1      }
 164          
 165          /**
 166           * @brief       APROM blank check
 167           * @param       u16IAPStartAddress define APROM area start address
 168           * @param       u16IAPDataSize define APROM need be erase bytes size
C51 COMPILER V9.52.0.0   IAP                                                               05/07/2021 15:15:29 PAGE 4   

 169           * @return      none
 170           * @details     Check each byte of APPROM is FFH or not.
 171           * @example     APROM_Blank_Check(0x0000,2048);
 172           */
 173          void APROM_Blank_Check(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
 174          {   
 175   1          unsigned int u16Count;
 176   1        
 177   1          set_CHPCON_IAPEN;
 178   1          IAPAL = LOBYTE(u16IAPStartAddress);
 179   1          IAPAH = HIBYTE(u16IAPStartAddress);
 180   1          IAPCN = BYTE_READ_APROM;
 181   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
 182   1          {   
 183   2              IAPFD = 0x00;    
 184   2              set_IAPTRG_IAPGO;
 185   2              if(IAPFD != 0xFF)
 186   2                while(1);
 187   2              IAPAL++;
 188   2              if(IAPAL == 0x00)
 189   2                IAPAH++;
 190   2          } 
 191   1          clr_CHPCON_IAPEN;
 192   1      }
 193          
 194          /**
 195           * @brief       APROM program loop
 196           * @param       u16IAPStartAddress define APROM area start address
 197           * @param       u16IAPDataSize define APROM need be erase bytes size
 198           * @return      none
 199           * @details     Copy APDataBuf to APROM
 200           * @example     APROM_Program(0x0000,1024);
 201           */
 202          void APROM_Program(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
 203          {   
 204   1          unsigned int u16Count;
 205   1      
 206   1          set_CHPCON_IAPEN;
 207   1          set_IAPUEN_APUEN;    
 208   1          IAPAL = LOBYTE(u16IAPStartAddress);
 209   1          IAPAH = HIBYTE(u16IAPStartAddress);
 210   1          IAPCN = BYTE_PROGRAM_APROM;
 211   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
 212   1          {   
 213   2              IAPFD=IAPDataBuf[u16Count];
 214   2              set_IAPTRG_IAPGO_WDCLR;
 215   2              IAPAL++;
 216   2              if(IAPAL == 0)
 217   2              {
 218   3                  IAPAH++;
 219   3              }
 220   2          } 
 221   1          clr_IAPUEN_APUEN;
 222   1          clr_CHPCON_IAPEN;
 223   1      }
 224          
 225          /**
 226           * @brief       APROM check loop
 227           * @param       u16IAPStartAddress define APROM area start address
 228           * @param       u16IAPDataSize define APROM need be erase bytes size
 229           * @return      none
 230           * @details     Check with XRAM IAPDataBuf with APROM
C51 COMPILER V9.52.0.0   IAP                                                               05/07/2021 15:15:29 PAGE 5   

 231           * @example     APROM_Program_Verify(0x0000,1024);
 232           */
 233          void APROM_Read_Verify(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
 234          {   
 235   1          unsigned int u16Count;
 236   1      
 237   1          set_CHPCON_IAPEN;
 238   1          IAPAL = LOBYTE(u16IAPStartAddress);
 239   1          IAPAH = HIBYTE(u16IAPStartAddress);
 240   1          IAPCN = BYTE_READ_APROM;
 241   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
 242   1          {   
 243   2              IAPFD = 0x00;
 244   2              set_IAPTRG_IAPGO_WDCLR;
 245   2              if (IAPFD != IAPDataBuf[u16Count])
 246   2                  while(1);
 247   2              IAPAL++;
 248   2              if(IAPAL == 0)
 249   2              {
 250   3                  IAPAH++;
 251   3              }
 252   2          } 
 253   1          clr_CHPCON_IAPEN;
 254   1      }
 255          
 256          /**
 257           * @brief       Read UID loop
 258           * @param       none
 259           * @return      none
 260           * @details     IAP command read UID area storage data in XRAM LIB_UIDBuffer[0:8]
 261           * @example     UID_Read();
 262          */
 263          void UID_Read(void)
 264          {   
 265   1          unsigned char u8Count;
 266   1      
 267   1          set_CHPCON_IAPEN;
 268   1          IAPAL = 0x00;
 269   1          IAPAH = 0x00;
 270   1          IAPCN = READ_UID;
 271   1          for(u8Count=0;u8Count<12;u8Count++)
 272   1          {   
 273   2              IAPFD = 0x00;
 274   2              set_IAPTRG_IAPGO;
 275   2              UIDBuffer[u8Count] = IAPFD ;
 276   2              IAPAL++;
 277   2          } 
 278   1          clr_CHPCON_IAPEN;
 279   1      }
 280          
 281          /**
 282           * @brief       Read UCID loop
 283           * @param       none
 284           * @return      none
 285           * @details     IAP command read UCID area storage data in XRAM UCIDBuffer[0:8]
 286           * @example      UCID_Read();
 287           */
 288          void UCID_Read(void)
 289          {   
 290   1          unsigned char u8Count;
 291   1      
 292   1          set_CHPCON_IAPEN;
C51 COMPILER V9.52.0.0   IAP                                                               05/07/2021 15:15:29 PAGE 6   

 293   1          IAPAL = 0x20;
 294   1          IAPAH = 0x00;
 295   1          IAPCN = READ_UID;
 296   1          for(u8Count=0;u8Count<12;u8Count++)
 297   1          {   
 298   2              IAPFD = 0x00;
 299   2              set_IAPTRG_IAPGO;
 300   2              UCIDBuffer[u8Count] = IAPFD ;
 301   2              IAPAL++;
 302   2          } 
 303   1          clr_CHPCON_IAPEN;
 304   1      }
 305          
 306          /**
 307           * @brief       Read UID loop
 308           * @param       none
 309           * @return      none
 310           * @details     IAP command read UID area storage data in XRAM LIB_UIDBuffer[0:8]
 311           * @example      UID_Read();
 312          */
 313          void DID_Read(void)
 314          {   
 315   1          unsigned char u8Count;
 316   1      
 317   1          set_CHPCON_IAPEN;
 318   1          IAPAL = 0x00;
 319   1          IAPAH = 0x00;
 320   1          IAPCN = READ_DID;
 321   1          for(u8Count=0;u8Count<4;u8Count++)
 322   1          {   
 323   2              IAPFD = 0x00;
 324   2              set_IAPTRG_IAPGO;
 325   2              DIDBuffer[u8Count] = IAPFD ;
 326   2              IAPAL++;
 327   2          } 
 328   1          clr_CHPCON_IAPEN;
 329   1      }
 330          
 331          /**
 332           * @brief       Calculate APROM Checksum
 333           * @param       u8IAPStartAddressHiByte: start address high byte
 334             @param       u8ChecksumSize. 0 means full Flash area. size = u8ChecksumSize*256 bytes  
 335           * @return      none
 336           * @details     Calculate APROM Checksum for 256 bytes based on start address. 
 337           * @example     APROM_Checksum_Run(0x3800,1) when start address is 0x3800.
 338          */
 339          void APROM_Checksum_Run(unsigned int u16IAPStartAddress,unsigned char u8ChecksumSize)
 340          {   
 341   1          set_CHPCON_IAPEN;
 342   1          IAPAL = 0x00;
 343   1          IAPAH = u16IAPStartAddress>>8;
 344   1          IAPFD = u8ChecksumSize;
 345   1          IAPCN = RUN_APROM_CHECKSUM;
 346   1          set_IAPTRG_IAPGO;
 347   1          clr_CHPCON_IAPEN;
 348   1      }
 349          
 350          /**
 351           * @brief       Read APROM Checksum
 352           * @param       u8IAPStartAddressHiByte: start address high byte
 353           * @return      Checksum value based on APROM_Checksum_Run setting.
 354           * @details     Read APROM Checksum based on start address.
C51 COMPILER V9.52.0.0   IAP                                                               05/07/2021 15:15:29 PAGE 7   

 355           * @example     APROM_Checksum_Read(0x3800) when start address is 0x3800.
 356          */
 357          unsigned char APROM_Checksum_Read(unsigned int u16IAPStartAddress)
 358          {   
 359   1          unsigned char CheckSumValue;
 360   1          set_CHPCON_IAPEN;
 361   1          IAPAL = 0x00;
 362   1          IAPAH = u16IAPStartAddress>>8;
 363   1          IAPCN = READ_APROM_CHECKSUM;
 364   1          IAPFD = 0x00;
 365   1          set_IAPTRG_IAPGO;
 366   1          CheckSumValue = IAPFD ;
 367   1          clr_CHPCON_IAPEN;
 368   1          return CheckSumValue;
 369   1      }
 370          
 371          /**
 372           * @brief       Calculate LDROM Checksum
 373           * @param       u8IAPStartAddressHiByte: start address high byte
 374           * @return      none
 375           * @details     Calculate LDROM Checksum for 256 bytes based on start address.
 376           * @example     LDROM_Checksum_Run(0x0000,1) when start address is 0x0000 and check 256 bytes.
 377          */
 378          void LDROM_Checksum_Run(unsigned int u16IAPStartAddress, unsigned char u8ChecksumSize)
 379          {   
 380   1          set_CHPCON_IAPEN;
 381   1          IAPAL = 0x00;
 382   1          IAPAH = u16IAPStartAddress>>8;
 383   1          IAPFD = u8ChecksumSize;
 384   1          IAPCN = RUN_LDROM_CHECKSUM;
 385   1          set_IAPTRG_IAPGO;
 386   1          clr_CHPCON_IAPEN;
 387   1      }
 388          
 389          /**
 390           * @brief       Read LDROM Checksum
 391           * @param       u8IAPStartAddressHiByte: start address high byte
 392           * @return      Checksum value based on LDROM_Checksum_Run setting.
 393           * @details     Read LDROM Checksum based on start address.
 394           * @example     LDROM_Checksum_Read(0x00) when start address is 0x0000.
 395          */
 396          unsigned char LDROM_Checksum_Read(unsigned int u16IAPStartAddress)
 397          {   
 398   1          unsigned char CheckSumValue;
 399   1          set_CHPCON_IAPEN;
 400   1          IAPAL = 0x00;
 401   1          IAPAH = u16IAPStartAddress>>8;
 402   1          IAPCN = READ_LDROM_CHECKSUM;
 403   1          IAPFD = 0x00;
 404   1          set_IAPTRG_IAPGO;
 405   1          CheckSumValue = IAPFD ;
 406   1          clr_CHPCON_IAPEN;
 407   1          return CheckSumValue;
 408   1      }
 409          /**
 410           * @brief       Calculate SPROM Checksum
 411           * @param       none
 412           * @return      none
 413           * @details     Calculate SPROM Checksum at 0x0180.
 414           * @example     SPROM_Checksum_Run()
 415          */
 416          void SPROM_Checksum_Run(void)
C51 COMPILER V9.52.0.0   IAP                                                               05/07/2021 15:15:29 PAGE 8   

 417          {   
 418   1          set_CHPCON_IAPEN;
 419   1          IAPAL = 0x80;
 420   1          IAPAH = 0x01;
 421   1          IAPCN = RUN_SPROM_CHECKSUM;
 422   1          set_IAPTRG_IAPGO;//set_IAPTRG_IAPGO;
 423   1          clr_CHPCON_IAPEN;
 424   1      }
 425          
 426          /**
 427           * @brief       Read SPROM Checksum
 428           * @param       none
 429           * @return      checksum value based on SPROM setting.
 430           * @details     Read SPROM Checksum at 0x0180.
 431           * @example     SPROM_Checksum_Read()
 432          */
 433          unsigned char SPROM_Checksum_Read(void)
 434          {   
 435   1          unsigned char CheckSumValue;
 436   1          set_CHPCON_IAPEN;
 437   1          IAPAL = 0x80;
 438   1          IAPAH = 0x01;
 439   1          IAPCN = READ_SPROM_CHECKSUM;
 440   1          IAPFD = 1;
 441   1          set_IAPTRG_IAPGO;
 442   1          CheckSumValue = IAPFD ;
 443   1          clr_CHPCON_IAPEN;
 444   1          return CheckSumValue;
 445   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2034    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    158      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
