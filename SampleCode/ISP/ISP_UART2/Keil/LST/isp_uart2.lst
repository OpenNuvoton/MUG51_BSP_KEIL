C51 COMPILER V9.52.0.0   ISP_UART2                                                         05/07/2021 15:19:52 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE ISP_UART2
OBJECT MODULE PLACED IN .\Output\isp_uart2.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\isp_uart2.c LARGE OMF2 ROM(COMPACT) OPTIMIZE(7,SPEED) BROWSE INCDIR(..\.
                    -.\..\..\Library\Device\Include;..\..\..\..\Library\StdDriver\inc;..\..\ISP_UART2) DEBUG PRINT(.\LST\isp_uart2.lst) TABS(
                    -2) OBJECT(.\Output\isp_uart2.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2021 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          //********************************************************************************************************
             -***
   8          //  File Function: MUG51 UART0 ISP subroutine
   9          //********************************************************************************************************
             -***
  10          #include "MUG51.h"
  11          #include "isp_uart2.h"
  12          
  13            xdata volatile uint8_t uart_rcvbuf[64]; 
  14            xdata volatile uint8_t uart_txbuf[64];
  15            data volatile uint8_t bufhead;
  16            data volatile uint16_t flash_address; 
  17            data volatile uint16_t AP_size;
  18            data volatile uint8_t g_timer1Counter;
  19            data volatile uint8_t count; 
  20            data volatile uint16_t g_timer0Counter;
  21            data volatile uint32_t g_checksum;
  22            data volatile uint32_t g_totalchecksum;
  23            bit volatile bUartDataReady;
  24            bit volatile g_timer0Over;
  25            bit volatile g_timer1Over;
  26            bit volatile g_programflag;
  27          
  28          unsigned char PID_highB,PID_lowB,DID_highB,DID_lowB,CONF0,CONF1,CONF2,CONF4;
  29          unsigned char recv_CONF0,recv_CONF1,recv_CONF2,recv_CONF4;
  30          
  31          
  32          void READ_ID(void)
  33          {
  34   1      //    set_CHPCON_IAPEN;
  35   1          IAPCN = READ_DID;
  36   1          IAPAH = 0x00;
  37   1          IAPAL = 0x00;
  38   1          set_IAPTRG_IAPGO;
  39   1          DID_lowB = IAPFD;
  40   1          IAPAL = 0x01;
  41   1          set_IAPTRG_IAPGO;
  42   1          DID_highB = IAPFD;
  43   1          IAPAL = 0x02;
  44   1          set_IAPTRG_IAPGO;
  45   1          PID_lowB = IAPFD;
  46   1          IAPAL = 0x03;
C51 COMPILER V9.52.0.0   ISP_UART2                                                         05/07/2021 15:19:52 PAGE 2   

  47   1          set_IAPTRG_IAPGO;
  48   1          PID_highB = IAPFD;
  49   1      }
  50          void READ_CONFIG(void)
  51          {
  52   1          IAPCN = BYTE_READ_CONFIG;
  53   1          IAPAH = 0x00;
  54   1          IAPAL = 0x00;
  55   1          set_IAPTRG_IAPGO;
  56   1          CONF0 = IAPFD;
  57   1          IAPAL = 0x01;
  58   1          set_IAPTRG_IAPGO;
  59   1          CONF1 = IAPFD;
  60   1          IAPAL = 0x02;
  61   1          set_IAPTRG_IAPGO;
  62   1          CONF2 = IAPFD;
  63   1          IAPAL = 0x04;
  64   1          set_IAPTRG_IAPGO;
  65   1          CONF4 = IAPFD;
  66   1      //    clr_CHPCON_IAPEN;
  67   1      }
  68          
  69          void TM0_ini(void)
  70          {    
  71   1        TH0=TL0=0;    //interrupt timer 140us
  72   1        set_TCON_TR0;      //Start timer0
  73   1        set_IPH_PSH;       // Serial port 0 interrupt level2
  74   1        set_IE_ET0;
  75   1      }
  76          
  77          
  78          void UART2_ini_115200(void)
  79          {
  80   1          MFP_P25_UART2_TXD;                              /* set P2.5 and P2.4 as Quasi mode for UART0 trasnfer 
             -*/
  81   1          MFP_P24_UART2_RXD;
  82   1          P25_PUSHPULL_MODE;
  83   1          P24_INPUT_MODE;
  84   1        
  85   1        set_SC0CR0_SCEN;         /* Enable SC module */
  86   1        set_SC0CR1_UARTEN;       /* set as UART mode */
  87   1        set_SC0CR1_CLKKEEP;      
  88   1        clr_SC0CR0_CONSEL;       /* clr CONSEL and AUTOCEN*/
  89   1        clr_SC0CR0_AUTOCEN;
  90   1        SC0ETURD0 = LOBYTE(24000000/8/115200-1);  /* define baud rate low byte */
  91   1        SC0ETURD1 &= 0xF0;                                /* define baud rate high byte */
  92   1        SC0ETURD1 |= (HIBYTE(24000000/8/115200-1))&0x0F; 
  93   1        set_SC0CR1_PBOFF;     //parity bit disable
  94   1        SC0CR1&=0XCF;        //datalegth 8bit
  95   1        set_SC0CR0_NSB;      //stop bit = 1bit  
  96   1        set_SC0IE_TBEIEN;
  97   1        set_SC0IE_RDAIEN;
  98   1        EA=1;
  99   1      }
 100          
 101          
 102          void Package_checksum(void)
 103          {
 104   1        g_checksum=0;
 105   1         for(count=0;count<64;count++)
 106   1        {
 107   2          g_checksum =g_checksum+ uart_rcvbuf[count];    
C51 COMPILER V9.52.0.0   ISP_UART2                                                         05/07/2021 15:19:52 PAGE 3   

 108   2        }
 109   1        uart_txbuf[0]=g_checksum&0xff;
 110   1        uart_txbuf[1]=(g_checksum>>8)&0xff;
 111   1        uart_txbuf[4]=uart_rcvbuf[4]+1;
 112   1        uart_txbuf[5]=uart_rcvbuf[5];
 113   1        if(uart_txbuf[4]==0x00)
 114   1        uart_txbuf[5]++;
 115   1      }
 116          
 117          
 118          void Send_64byte_To_UART2(void)
 119          {
 120   1         for(count=0;count<64;count++)
 121   1        {
 122   2          clr_SC0CR0_TXOFF;
 123   2          SC0DR = uart_txbuf[count];
 124   2          while((SC0TSR|CLR_BIT3)==CLR_BIT3);
 125   2          clr_SC0CR0_TXOFF;
 126   2        }
 127   1      }
 128          
 129          void SMC0_ISR (void) interrupt 19  
 130          {
 131   1          SFRS=0;
 132   1          if((SC0IS|CLR_BIT0)==0xFF)
 133   1          {   
 134   2            uart_rcvbuf[bufhead++]=  SC0DR;
 135   2            clr_SC0IS_RDAIF;                                         // Clear RI (Receive Interrupt).
 136   2          }
 137   1          if ((SC0IS|CLR_BIT1)==0xFF)
 138   1          {       
 139   2              clr_SC0IS_TBEIF;                                         // Clear TI (Transmit Interrupt).
 140   2          }
 141   1          if(bufhead ==1)
 142   1          {
 143   2            g_timer1Over=0;
 144   2            g_timer1Counter=90; //for check uart timeout using
 145   2          }
 146   1        if(bufhead == 64)
 147   1          {
 148   2            bUartDataReady = TRUE;
 149   2            g_timer1Counter=0;
 150   2            g_timer1Over=0;
 151   2            bufhead = 0;
 152   2          }    
 153   1      }
 154          
 155          void Timer0_ISR (void) interrupt 1
 156          {
 157   1      //    _push_(SFRS);
 158   1        
 159   1      if(g_timer0Counter)
 160   1        {
 161   2        g_timer0Counter--;
 162   2          if(!g_timer0Counter)
 163   2          {
 164   3          g_timer0Over=1;
 165   3          }
 166   2        }
 167   1        
 168   1        if(g_timer1Counter)
 169   1        {
C51 COMPILER V9.52.0.0   ISP_UART2                                                         05/07/2021 15:19:52 PAGE 4   

 170   2        g_timer1Counter--;
 171   2          if(!g_timer1Counter)
 172   2          {
 173   3          g_timer1Over=1;
 174   3          }
 175   2        }
 176   1        
 177   1      //    _pop_(SFRS);
 178   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    659    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    140    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
